setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
data <- read.csv("life.rm.csv"); year <- 18
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
View(data)
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
i=1
i=1L
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
View(col)
collected.col <- data[, col]
View(collected.col)
key <- collected.col[na.row[i],] #key observation의 row 추출
View(key)
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
View(c)
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 합.
View(c)
n.point <- order(p.length)[2:6] #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
answer <- data[,c(1, 2, year)
data[,c(1, 2, year)]
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
View(data)
co2 <- read.csv("co2.rm.csv")
View(co2)
View(collected.col)
data <- read.csv("ter.rm.csv"); year <- 18
rm(list=ls())
n.point <- NULL
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
data <- read.csv("ter.rm.csv"); year <- 18
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
i<-1L
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
j <- 2L
n.point <- NULL
while(length(n.point) >= 5) {
if(order(p.length)[j] == NA) n.point <- order(p.length)[j] #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
j <- 2L
n.point <- NULL
while(length(n.point) >= 5) {
if(order(p.length)[j] == NA) n.point <- order(p.length)[j] #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
while(length(n.point) >= 5) {
if(order(p.length)[j] == NA) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
length(n.point)
while(length(n.point) <= 5) {
if(order(p.length)[j] == NA) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(temp) == NA) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(temp == NA) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
temp <- order(p.length)[j]
if(is.na(temp)) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(is.na(temp)) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(!is.na(temp)) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
n.point <- NULL
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(!is.na(temp)) n.point <- c(n.point, order(p.length)[j]) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(!is.na(temp)) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
j <- 2L; n.point <- NULL
temp <- order(p.length)[j]
if(!is.na(temp)) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
length(n.point) <= 5
temp <- order(p.length)[j]
if(!is.na(temp)) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
j <- 2L; n.point <- NULL
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
!is.na(data[temp, year])
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
j <- 2L; n.point <- NULL
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
length(n.point) <= 5
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
length(n.point) <= 5
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
j <- 2L; n.point <- NULL
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
data <- read.csv("ter.rm.csv"); year <- 17
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
i<-1L
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
j <- 2L; n.point <- NULL
while(length(n.point) <= 5) {
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) #첫번째 요소는 자기 자신이라서 제외해줬다. key와 가장 가까운 5개의 point 추출
j <- j+1
}
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
KNN <- function(data, year){
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
for(i in 1:length(na.row)){
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
j <- 2L; n.point <- NULL #첫번째 요소는 자기 자신이라서 제외해줬다.
while(length(n.point) <= 5) { #key와 가장 가까운 5개의 point 추출
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) # if selected point's year data is not NA, then push temp to n.point
j <- j+1
}
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
}
return(data[,c(1, 2, year)])
}
life <- read.csv("life.rm.csv")
rm(list=ls())
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
KNN <- function(data, year){
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
for(i in 1:length(na.row)){
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
j <- 2L; n.point <- NULL #첫번째 요소는 자기 자신이라서 제외해줬다.
while(length(n.point) <= 5) { #key와 가장 가까운 5개의 point 추출
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) # if selected point's year data is not NA, then push temp to n.point
j <- j+1
}
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
}
return(data[,c(1, 2, year)])
}
life <- read.csv("life.rm.csv")
life.0 <- KNN(life, 18)
gdp <- read.csv("gdp.rm.csv")
gdp.0 <- KNN(gdp, 19)
co2 <- read.csv("co2.rm.csv")
co2.0 <- KNN(co2, 17)
ter <- read.csv("ter.rm.csv")
ter.0 <- KNN(ter, 18)
ter.0 <- KNN(ter, 18)
smo <- read.csv("smo.rm.2.CSV")
which(is.na(smo[,3]))
which(is.na(smo[,4]))
avg <- apply(smo[,c(3,4)], 2, mean, na.rm = T)
smo[which(is.na(smo[,3])),3] <- avg[1]
smo[which(is.na(smo[,4])),4] <- avg[2]
sec <- read.csv("sec.rm.csv")
sec.0 <- KNN(sec, 18)
obesity <- read.csv("Obesity.rm.csv", header=T)
KNN(obesity, 19)
obs.0 <- obesity[,c(1, 2, 19)]
hiv <- read.csv("hiv.rm.csv")
hiv.0 <- KNN(hiv, 19)
sani <- read.csv("sani.rm.csv")
sani.0 <- KNN(sani, 18)
pre <- read.csv("pre.rm.csv")
pri <- read.csv("pri.rm.csv")
ter.0 <- KNN(ter, 18)
time <- proc.time()
life.0 <- KNN(life, 18)
proc.time() - time
time <- proc.time()
ter.0 <- KNN(ter, 18)
data <- ter; year <- 18
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
for(i in 1:length(na.row)){
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
j <- 2L; n.point <- NULL #첫번째 요소는 자기 자신이라서 제외해줬다.
while(length(n.point) <= 5) { #key와 가장 가까운 5개의 point 추출
temp <- order(p.length)[j]
if(!is.na(data[temp, year])) n.point <- c(n.point, temp) # if selected point's year data is not NA, then push temp to n.point
j <- j+1
}
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
}
install.packages("class")
knn(train = ter)
library(class)
knn(train = ter)
knn(train = ter[,-c(1,2)])
knn(train = ter[,-c(1,2)], ter[,18])
knn(train = ter[,-c(1,2)], ter[,18], na.rm=T)
knn(train = ter[,-c(1,2)], ter[,18], k = 5)
pre.0 <- KNN(pre, 18)
pre.0 <- KNN(pre, 18)
ter.0 <- KNN(ter, 17)
View(life.0)
life.1 <- read.csv("life.rv.csv")
setwd("C:/Users/정은/Desktop/new_bigdata_set/new data revised")
life.1 <- read.csv("life.rv.csv")
life.0 <- KNN(life, 18)
identical(life.0, life.1)
View(life.0)
View(life.1)
data <- life; year <- 18
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
i <- 1L
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
rm(list=ls())
life <- read.csv("life.rm.csv")
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
life <- read.csv("life.rm.csv")
data <- life; year <- 18
i <- 1L
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
for(i in 1:length(na.row)){
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
j <- 2L; n.point <- NULL #첫번째 요소는 자기 자신이라서 제외해줬다.
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
}
i <- 1L
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
o.p <- order(p.length)
!is.na(data[o.p, year])
which(!is.na(data[o.p, year]))
o.p[which(!is.na(data[o.p, year]))]
o.p[which(!is.na(data[o.p, year]))][1:5]
KNN.0 <- function(data, year){
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
for(i in 1:length(na.row)){
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
o.p <- order(p.length)
n.point <- o.p[which(!is.na(data[o.p, year]))][1:5]
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
}
return(data[,c(1, 2, year)])
}
ter <- read.csv("ter.rm.csv")
ter.0 <- KNN1(ter, 18)
ter.0 <- KNN.0(ter, 18)
View(ter.0)
time <- proc.time()
ter.0 <- KNN.0(ter, 18)
proc.time() - time
rm(list=ls())
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
setwd("c:/Users/정은/Desktop/new_bigdata_set/above 2000")
KNN <- function(data, year){
if(length(which(is.na(data[,year]))) == 0) return(data[,c(1,2, year)])
na.row <- which(is.na(data[, year])) #기준 년도에서 NA인 row추출
for(i in 1:length(na.row)){
col <- !is.na(data[na.row[i],]) #key observation에서 NA가 아닌 col 추출
collected.col <- data[, col] #data에서 col column들을 추출
key <- collected.col[na.row[i],] #key observation의 row 추출
index <- complete.cases(collected.col) #NA가 하나도 없는 row 추출
non.na <- collected.col[index,] #NA를 제거함.
a <- apply(as.data.frame(non.na[,-c(1,2)]), 1, "-", key[,-c(1,2)]) #두 값의 차
b <- unlist(a) ^ 2 #차의 제곱
c <- as.data.frame(matrix(b, length(b)/(length(collected.col)-2),
length(collected.col)-2, byrow = T)) #vector b를 data.frame으로 형변환
colnames(c) <- colnames(non.na)[-c(1, 2)]
p.length <- apply(c, 1, sum) #각 년도별로 구해진 길이들의 평균.
o.p <- order(p.length)
n.point <- o.p[which(!is.na(data[o.p, year]))][1:5]
d <- data[n.point, year] #key와 가까운 5개의 point의 점수 추출
data[na.row[i], year] <- mean(d, na.rm = T) # 추출된 근처 값들의 평균을 넣어줌.
}
return(data[,c(1, 2, year)])
}
life <- read.csv("life.rm.csv")
life.0 <- KNN(life, 18)
gdp <- read.csv("gdp.rm.csv")
gdp.0 <- KNN(gdp, 19)
co2 <- read.csv("co2.rm.csv")
co2.0 <- KNN(co2, 17)
ter <- read.csv("ter.rm.csv")
ter.0 <- KNN(ter, 18)
smo <- read.csv("smo.rm.2.CSV")
which(is.na(smo[,3]))
which(is.na(smo[,4]))
avg <- apply(smo[,c(3,4)], 2, mean, na.rm = T)
smo[which(is.na(smo[,3])),3] <- avg[1]
smo[which(is.na(smo[,4])),4] <- avg[2]
sec <- read.csv("sec.rm.csv")
sec.0 <- KNN(sec, 18)
obesity <- read.csv("Obesity.rm.csv", header=T)
KNN(obesity, 19)
obs.0 <- obesity[,c(1, 2, 19)]
hiv <- read.csv("hiv.rm.csv")
hiv.0 <- KNN(hiv, 19)
pre <- read.csv("pre.rm.csv")
pre.0 <- KNN(pre, 18)
pri <- read.csv("pri.rm.csv")
pri.0 <- KNN(pri, 18)
sani <- read.csv("sani.rm.csv")
sani.0 <- KNN(sani, 18)
write.csv(co2.0, "co2.rv.csv", row.names = F)
write.csv(gdp.0, "gdp.rv.csv", row.names = F)
write.csv(hiv.0, "hiv.rv.csv", row.names = F)
write.csv(life.0, "life.rv.csv", row.names = F)
write.csv(obs.0, "ob.rv.csv", row.names = F)
write.csv(pre.0, "pre.rv.csv", row.names = F)
write.csv(pri.0, "pri.rv.csv", row.names = F)
write.csv(sani.0, "sani.rv.csv", row.names = F)
write.csv(smo, "smo.rv.csv", row.names = F)
write.csv(sec.0, "sec.rv.csv", row.names = F)
write.csv(ter.0, "ter.rv.csv", row.names = F)
setwd("C:/Users/정은/Desktop/new_bigdata_set/new data revised")
co2.1 <- read.csv("co2.rv.csv")
View(co2.1)
View(co2.0)
View(co2.1)
View(co2.0)
View(co2.1)
View(co2.0)
View(co2.1)
identical(co2.0, co2.1)
